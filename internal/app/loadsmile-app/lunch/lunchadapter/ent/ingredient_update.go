// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/prasetyowira/loadsmile/internal/app/loadsmile-app/lunch/lunchadapter/ent/ingredient"
	"github.com/prasetyowira/loadsmile/internal/app/loadsmile-app/lunch/lunchadapter/ent/predicate"
	"github.com/prasetyowira/loadsmile/internal/app/loadsmile-app/lunch/lunchadapter/ent/recipe"
)

// IngredientUpdate is the builder for updating Ingredient entities.
type IngredientUpdate struct {
	config

	title          *string
	best_before    *time.Time
	use_by         *time.Time
	clearuse_by    bool
	created_at     *time.Time
	updated_at     *time.Time
	recipes        map[int]struct{}
	removedRecipes map[int]struct{}
	predicates     []predicate.Ingredient
}

// Where adds a new predicate for the builder.
func (iu *IngredientUpdate) Where(ps ...predicate.Ingredient) *IngredientUpdate {
	iu.predicates = append(iu.predicates, ps...)
	return iu
}

// SetTitle sets the title field.
func (iu *IngredientUpdate) SetTitle(s string) *IngredientUpdate {
	iu.title = &s
	return iu
}

// SetBestBefore sets the best_before field.
func (iu *IngredientUpdate) SetBestBefore(t time.Time) *IngredientUpdate {
	iu.best_before = &t
	return iu
}

// SetUseBy sets the use_by field.
func (iu *IngredientUpdate) SetUseBy(t time.Time) *IngredientUpdate {
	iu.use_by = &t
	return iu
}

// SetNillableUseBy sets the use_by field if the given value is not nil.
func (iu *IngredientUpdate) SetNillableUseBy(t *time.Time) *IngredientUpdate {
	if t != nil {
		iu.SetUseBy(*t)
	}
	return iu
}

// ClearUseBy clears the value of use_by.
func (iu *IngredientUpdate) ClearUseBy() *IngredientUpdate {
	iu.use_by = nil
	iu.clearuse_by = true
	return iu
}

// SetCreatedAt sets the created_at field.
func (iu *IngredientUpdate) SetCreatedAt(t time.Time) *IngredientUpdate {
	iu.created_at = &t
	return iu
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (iu *IngredientUpdate) SetNillableCreatedAt(t *time.Time) *IngredientUpdate {
	if t != nil {
		iu.SetCreatedAt(*t)
	}
	return iu
}

// SetUpdatedAt sets the updated_at field.
func (iu *IngredientUpdate) SetUpdatedAt(t time.Time) *IngredientUpdate {
	iu.updated_at = &t
	return iu
}

// AddRecipeIDs adds the recipes edge to Recipe by ids.
func (iu *IngredientUpdate) AddRecipeIDs(ids ...int) *IngredientUpdate {
	if iu.recipes == nil {
		iu.recipes = make(map[int]struct{})
	}
	for i := range ids {
		iu.recipes[ids[i]] = struct{}{}
	}
	return iu
}

// AddRecipes adds the recipes edges to Recipe.
func (iu *IngredientUpdate) AddRecipes(r ...*Recipe) *IngredientUpdate {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return iu.AddRecipeIDs(ids...)
}

// RemoveRecipeIDs removes the recipes edge to Recipe by ids.
func (iu *IngredientUpdate) RemoveRecipeIDs(ids ...int) *IngredientUpdate {
	if iu.removedRecipes == nil {
		iu.removedRecipes = make(map[int]struct{})
	}
	for i := range ids {
		iu.removedRecipes[ids[i]] = struct{}{}
	}
	return iu
}

// RemoveRecipes removes recipes edges to Recipe.
func (iu *IngredientUpdate) RemoveRecipes(r ...*Recipe) *IngredientUpdate {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return iu.RemoveRecipeIDs(ids...)
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (iu *IngredientUpdate) Save(ctx context.Context) (int, error) {
	if iu.updated_at == nil {
		v := ingredient.UpdateDefaultUpdatedAt()
		iu.updated_at = &v
	}
	return iu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (iu *IngredientUpdate) SaveX(ctx context.Context) int {
	affected, err := iu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (iu *IngredientUpdate) Exec(ctx context.Context) error {
	_, err := iu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iu *IngredientUpdate) ExecX(ctx context.Context) {
	if err := iu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (iu *IngredientUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   ingredient.Table,
			Columns: ingredient.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: ingredient.FieldID,
			},
		},
	}
	if ps := iu.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := iu.title; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: ingredient.FieldTitle,
		})
	}
	if value := iu.best_before; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldBestBefore,
		})
	}
	if value := iu.use_by; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldUseBy,
		})
	}
	if iu.clearuse_by {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: ingredient.FieldUseBy,
		})
	}
	if value := iu.created_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldCreatedAt,
		})
	}
	if value := iu.updated_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldUpdatedAt,
		})
	}
	if nodes := iu.removedRecipes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   ingredient.RecipesTable,
			Columns: ingredient.RecipesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: recipe.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iu.recipes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   ingredient.RecipesTable,
			Columns: ingredient.RecipesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: recipe.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, iu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ingredient.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// IngredientUpdateOne is the builder for updating a single Ingredient entity.
type IngredientUpdateOne struct {
	config
	id int

	title          *string
	best_before    *time.Time
	use_by         *time.Time
	clearuse_by    bool
	created_at     *time.Time
	updated_at     *time.Time
	recipes        map[int]struct{}
	removedRecipes map[int]struct{}
}

// SetTitle sets the title field.
func (iuo *IngredientUpdateOne) SetTitle(s string) *IngredientUpdateOne {
	iuo.title = &s
	return iuo
}

// SetBestBefore sets the best_before field.
func (iuo *IngredientUpdateOne) SetBestBefore(t time.Time) *IngredientUpdateOne {
	iuo.best_before = &t
	return iuo
}

// SetUseBy sets the use_by field.
func (iuo *IngredientUpdateOne) SetUseBy(t time.Time) *IngredientUpdateOne {
	iuo.use_by = &t
	return iuo
}

// SetNillableUseBy sets the use_by field if the given value is not nil.
func (iuo *IngredientUpdateOne) SetNillableUseBy(t *time.Time) *IngredientUpdateOne {
	if t != nil {
		iuo.SetUseBy(*t)
	}
	return iuo
}

// ClearUseBy clears the value of use_by.
func (iuo *IngredientUpdateOne) ClearUseBy() *IngredientUpdateOne {
	iuo.use_by = nil
	iuo.clearuse_by = true
	return iuo
}

// SetCreatedAt sets the created_at field.
func (iuo *IngredientUpdateOne) SetCreatedAt(t time.Time) *IngredientUpdateOne {
	iuo.created_at = &t
	return iuo
}

// SetNillableCreatedAt sets the created_at field if the given value is not nil.
func (iuo *IngredientUpdateOne) SetNillableCreatedAt(t *time.Time) *IngredientUpdateOne {
	if t != nil {
		iuo.SetCreatedAt(*t)
	}
	return iuo
}

// SetUpdatedAt sets the updated_at field.
func (iuo *IngredientUpdateOne) SetUpdatedAt(t time.Time) *IngredientUpdateOne {
	iuo.updated_at = &t
	return iuo
}

// AddRecipeIDs adds the recipes edge to Recipe by ids.
func (iuo *IngredientUpdateOne) AddRecipeIDs(ids ...int) *IngredientUpdateOne {
	if iuo.recipes == nil {
		iuo.recipes = make(map[int]struct{})
	}
	for i := range ids {
		iuo.recipes[ids[i]] = struct{}{}
	}
	return iuo
}

// AddRecipes adds the recipes edges to Recipe.
func (iuo *IngredientUpdateOne) AddRecipes(r ...*Recipe) *IngredientUpdateOne {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return iuo.AddRecipeIDs(ids...)
}

// RemoveRecipeIDs removes the recipes edge to Recipe by ids.
func (iuo *IngredientUpdateOne) RemoveRecipeIDs(ids ...int) *IngredientUpdateOne {
	if iuo.removedRecipes == nil {
		iuo.removedRecipes = make(map[int]struct{})
	}
	for i := range ids {
		iuo.removedRecipes[ids[i]] = struct{}{}
	}
	return iuo
}

// RemoveRecipes removes recipes edges to Recipe.
func (iuo *IngredientUpdateOne) RemoveRecipes(r ...*Recipe) *IngredientUpdateOne {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return iuo.RemoveRecipeIDs(ids...)
}

// Save executes the query and returns the updated entity.
func (iuo *IngredientUpdateOne) Save(ctx context.Context) (*Ingredient, error) {
	if iuo.updated_at == nil {
		v := ingredient.UpdateDefaultUpdatedAt()
		iuo.updated_at = &v
	}
	return iuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (iuo *IngredientUpdateOne) SaveX(ctx context.Context) *Ingredient {
	i, err := iuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return i
}

// Exec executes the query on the entity.
func (iuo *IngredientUpdateOne) Exec(ctx context.Context) error {
	_, err := iuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (iuo *IngredientUpdateOne) ExecX(ctx context.Context) {
	if err := iuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (iuo *IngredientUpdateOne) sqlSave(ctx context.Context) (i *Ingredient, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   ingredient.Table,
			Columns: ingredient.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  iuo.id,
				Type:   field.TypeInt,
				Column: ingredient.FieldID,
			},
		},
	}
	if value := iuo.title; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeString,
			Value:  *value,
			Column: ingredient.FieldTitle,
		})
	}
	if value := iuo.best_before; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldBestBefore,
		})
	}
	if value := iuo.use_by; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldUseBy,
		})
	}
	if iuo.clearuse_by {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Column: ingredient.FieldUseBy,
		})
	}
	if value := iuo.created_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldCreatedAt,
		})
	}
	if value := iuo.updated_at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: ingredient.FieldUpdatedAt,
		})
	}
	if nodes := iuo.removedRecipes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   ingredient.RecipesTable,
			Columns: ingredient.RecipesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: recipe.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := iuo.recipes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   ingredient.RecipesTable,
			Columns: ingredient.RecipesPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: recipe.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	i = &Ingredient{config: iuo.config}
	_spec.Assign = i.assignValues
	_spec.ScanValues = i.scanValues()
	if err = sqlgraph.UpdateNode(ctx, iuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ingredient.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return i, nil
}
